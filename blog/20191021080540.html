<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="stylesheet" type="text/css" href="/css/common.css">
<link rel="shortcut icon" href="/images/philosophi-favicon.png">

<title>Perlのプレインオールドを再評価する - 単純で古典的ということの価値 - Perlの哲学 - Perlに対する誤解を解きたい</title>
<meta name="description" content="Perlは、1987年に誕生したプログラミング言語です。起源は古く、現代的な動的型言語の元祖です。言語の仕組みは単純なものを採用しています。">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<h1>
  <a href="/"><img src="/images/philosophi-logo.png" alt="Perlの哲学 - Perlに対する誤解を解く"></a>
</h1>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    <!-- top -->

  </div>
  <div class="middle">
    <h2><a href="/blog/20191021080540.html">Perlのプレインオールドを再評価する - 単純で古典的ということの価値</a></h2>
<p>
  Perlは、1987年に誕生したプログラミング言語です。起源は古く、現代的な動的型言語の元祖です。言語の仕組みは単純なものを採用しています。
</p>
<p>
  Perlは、時流と流行と人気に乗り、新しいことを常に取り入れるといったようなプログラミング言語ではありません。
</p>
<p>
  古典的で簡単な解決方法で解決できるものは、それを使い、新しい分野で必要があれば、時間をかけて取り入れていきます。
</p>
<p>
  Perlは、日常の作業でよく使うテキスト処理に着目し、ユーザーが簡単に使えることが特徴です。
</p>
<p>
  後方互換性は非常に高く、安定してシステムを運用することができます。
</p>
<p>
  以下では、Perlにおける単純な仕組みについて、いくつか例を挙げてみます。
</p>
<h3>リファレンスカウント式のGC</h3>
<p>
  Perlは、古典的で簡単なリファレンスカウント式のGCを採用しています。
</p>
<p>
  <a href="https://tutorial.perlzemi.com/blog/20131010138141.html">Perlのガーベッジコレクション(GC)の特性について - リファレンスカウントGC</a>
</p>
<p>
  リファレンスカウント式のGCの強みは、GCの中では、実装が最もシンプルなことです。リファレンスカウントが0になったオブジェクトを解放するという実装です。
</p>
<p>
  プログラミング言語の内部的な実装において、実装内容は一貫しており、Perlのバージョンによって、変化するということは、ほぼありません。
</p>
<p>
  ユーザーから見た嬉しい点は何でしょう。それは、レイテンシを小さくできることです。
</p>
<p>
  リファレンスカウント方式GCでは、オブジェクトが破棄されるたびに、GCを行うので、GCの蓄積が起こりません。
</p>
<p>
  高パフォーマンスのために必要な、Webサーバーの実装であるノンブロッキングI/Oでは、待ち時間が小さいということは非常に重要です。
</p>
<p>
  Perlは、大量のテキストを扱うことにパフォーマンスを最適化しており、これは、大量のオブジェクトの生成と破棄が起こるということも想定されています。
</p>
<p>
  リファレンスカウントGCのデメリットは、率直にいうと、スループットが世代別GCに比べて低いことと、長くオブジェクトが存在することが想定されるプログラムにおいて、循環参照が起こったときは、弱参照の機能を使って、自分で管理する必要があることです。
</p>
<p>
  Perl以後の時代は、リファレンスカウントGCを古くて悪い実装と、かつてみなしましたが、Webサーバーの実装であるノンブロッキングI/Oにおいては、待ち時間が小さいことが、パフォーマンスにとって、重要なことが明らかになったため、リファレンスカウントGCの再評価が行われています。
</p>
<h3>シングルスレッド</h3>
<p>
  Perlプログラムは、シングルスレッドを前提として、動くことが想定されています。かつてPerlは、スレッドの方向を目指しましたが、現在ではPerlの持つスレッド機能は、非推奨となっています。
</p>
<p>
  理由は、Perlコア自体は、スレッドをサポートできることが可能であったとしても、CPANモジュールなど第三者が作ったモジュールは、スレッドを想定していないためです。
</p>
<p>
  そのため、Perlは安全なスレッドを目指しましたが、そのスレッドは、非常に重く、スレッドとして求められる水準に達しなかったのです。
</p>
<p>
  ですから、LinuxサーバーでコンパイルされるPerlは、標準で、スレッドサポートを外して、10%程度、パフォーマンスを上げる方向を選びました。
</p>
<p>
  実は、スレッドは、存在することが自体が、パフォーマンスを下げる要因となります。
</p>
<p>
  Perlは、スレッドの利便性と複雑性を選択しないで、単純さとパフォーマンスを上げる方向を選択しました。これがPerl言語のひとつの個性ともなっています。
</p>
<p>
  誤解を招くといけないので、追記しておきますが、スレッドがないということはマルチCPUをフルに使えないとういことは意味していません。
</p>
<p>
  それについては、こちらの記事をどうぞ。
</p>
<p>
  <a href="/blog/20190918081634.html">PerlでもマルチCPUを最大限に活用できる</a>
</p>
<h3>Perlは複雑と聞いていますが、実際はそうではないのですか?</h3>
<p>
  ここまで読むと「世の中では、Perlは複雑と言われているけれど、実際はそうではないのか」という疑問を抱かれることでしょう。
</p>
<p>
  半分本当、半分間違いですね。
</p>
<p>
  Perlの複雑と思える原因のひとつは、言語側ではなくって、シンタックシュシュガーにあります。
</p>
<p>
  シンタックシュガーとは、何回も書くのが面倒なので、簡単に書ける記法を用意しましょうというものです。また、意味を間違えやすいので、わかりやすい記法を導入しましょうというものです。
</p>
<p>
  たとえば、Perlでは、以下の意味は、同じなのですが、二つの表現が存在します。
</p>
<pre>
my %person = ('name', 'yuki', 'age', 19);

my %person = (name =&gt; 'yuki', age =&gt; 19);
</pre>
<p>
  Perlは、コンピューターから見た意味が同じなのに、人間から見たときに、見た目が違うという、シンタックシュガーが存在するのです。
</p>
<p>
  このために、表面的に、複雑なような印象を受けます。
</p>
<p>
  ただし、シンタックシュシュガーは、近年見直されてきており、Perl以外の言語にも、取り入れられることが多くなってきています。
</p>
<p>
  たとえばkotlinという言語は、Javaとの互換性を確保しつつ、Java言語にシンタックシュガーを取り入れたような言語として設計されていますね。
</p>
<p>
  Perl風のシンタックシュガーの採用も多くみられます。
</p>
<p>
  ただし、書き方が複数あることは、良い書き方が選ばれなかった場合、保守性を低くするということもまた真実であります。
</p>
<p>
  ですので、開発を始める前には、長い間の知識の蓄積から、ベストプラクティスと呼ばれるものが、存在するので、一度目を通しておくとよいと思います。
</p>
<p>
  <a href="https://tutorial.perlzemi.com/blog/20091120124667.html">現代的なPerlの記述方法一覧</a>
</p>

  </div>
  <div class="bottom">
    <!-- bottom -->

  </div>
</div>

        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    目次
  </div>
  <ul>
    <li><a href="/list.html">記事の一覧</a></li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="https://github.com/yuki-kimoto/giblog">Giblog</a>

      </div>
    </div>
  </body>
</html>
